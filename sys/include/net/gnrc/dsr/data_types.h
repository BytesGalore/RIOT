/*
 * Copyright (C) 2015 Martin Landsmann <martin.landsmann@haw-hamburg.de>
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @ingroup net_gnrc_dsr
 * @{
 *
 * @file
 * @brief       DSR data types
 *
 * Header file defining all types used by DSR.
 *
 * @author      Martin Landsmann <martin.landsmann@haw-hamburg.de>
 */

#ifndef GNRC_DSR_DATA_TYPES_H_
#define GNRC_DSR_DATA_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "net/ipv6/addr.h"

/** respond on error */
#define DSR_OPT_TYPE_ERR_RESPOND_REQUEST (0x80)

/** how to act on OPTION_NOT_SUPPORTED  */
#define DSR_OPT_TYPE_OPTION_NOT_SUPPORTED (0x60)

/** dispatch for unsupported option behaviour */
typedef enum{
    /** 0x00: MUST skip over the option and continue */
    ignore_option = 0,
    /** 0x01: MUST remove the option from the packet and continue */
    remove_option = 1,
    /** 0x10: MUST set msb after opt_data_length, skip and continue */
    mark_option   = 2,
    /** 0x11: MUST drop the packet */
    drop_packet   = 3,
}dsr_opt_error_dispatch_e;

/** value indicating no next header is following the DSR header */
#define DSR_NO_NEXT_HEADER (59)

/**
 * @brief Fixed Portion of DSR Options Header
 */
typedef struct{
    /** Next Header (59 == No Next Header)*/
    uint8_t next_header;
    union{
        /** the flow label bit */
        uint8_t flow_state : 1;
        /** reserved unused bits MUST be 0 */
        uint8_t reserved_bits;
    }flags;
    /** payload length (include all options excluding this header size) */
    uint16_t payload_length;
}dsr_opt_hdr_t;

/**
 * @brief Route Request Option
 */
typedef struct{
    /** option type */
    uint8_t opt_type;
    /** option data length excluding the Option Type and Opt Data Len fields
    *   MUST be set equal to (4 * n) + 6, where n is the number of addresses
    *   for IPv6 (sizeof(ipv6_addr_t)*n) + sizeof(uint16_t)+sizeof(ipv6_addr_t)
    *   in the Route Request Option
    */
    uint8_t opt_data_length;
    /** uinique ID generated by the originator of this rreq */
    uint16_t identification;
    
    /** the target of this source route */
    ipv6_addr_t target_address;
    /** pointer to the array of the source route hops */
    // handled externally 
    //ipv6_addr_t* address_array;
}dsr_route_request_option_t;


typedef struct{ 
    /** option type */
    uint8_t opt_type;
}dsr_opt_pad1;

typedef struct{
    /** option type */
    uint8_t opt_type;
    /** number of padding 0  bytes */
    uint8_t opt_data_length;
    /** padding 0 bytes octets array */
    uint8_t* opt_data;
}dsr_opt_padN;

typedef struct{
    /** option type */
    uint8_t opt_type;
    /** option data length 
    *   MUST be set equal to (4 * n) + 6, where n is the number of addresses
    *   in the Route Request Option
    */
    uint8_t opt_data_length;

    union{
        /** First hop external */
        uint16_t F : 1;
        /** Last Hop external */
        uint16_t L : 1;
        /** MUST be 0 */
        uint16_t reservd : 4;
        /** salvage count */
        uint16_t salvage : 4;
        /** number of remaining segments */
        uint16_t segs_left : 6;
    }flags;
    /** pointer to the array of the source route hops 
     * (n = (Opt Data Len - 1) / 4)
     * */
    ipv6_addr_t* address_array;
}dsr_source_route_option_t;



typedef struct{
    /** option type */
    uint8_t opt_type;
    /** option data length 
    *   MUST be set equal to (4 * n) + 6, where n is the number of addresses
    *   in the Route Request Option
    */
    uint8_t opt_data_length;
    uint16_t opt_identification;
    ipv6_addr_t ack_src_addr;
    ipv6_addr_t ack_dst_addr;
}dsr_opt_ack_t;

typedef struct{
    /** option type */
    uint8_t opt_type;
    /** option data length 
    *   MUST be set equal to (4 * n) + 6, where n is the number of addresses
    *   in the Route Request Option
    */
    uint8_t opt_data_length;
    uint16_t opt_identification;
}dsr_opt_ack_request_t;

typedef struct{
    ipv6_addr_t addr;
}dsr_unreachable_node_t;

typedef union{
    dsr_unreachable_node_t* unreachable_node;
    uint8_t unsupported_option;
}dsr_error_type_meta_t;

typedef struct{
    /** option type */
    uint8_t opt_type;
    /** option data length 
    *   MUST be set equal to (4 * n) + 6, where n is the number of addresses
    *   in the Route Request Option
    */
    uint8_t opt_data_length;
    
    /** error types
     * 1 = NODE_UNREACHABLE
     * 2 = FLOW_STATE_NOT_SUPPORTED
     * 3 = OPTION_NOT_SUPPORTED
     */
    uint8_t error_type;
    
    union{
        /** MUST be 0 */
        uint8_t reservd : 4;
        /** salvage count */
        uint8_t salvage : 4;
    }flags;
    /** Error Source Address */
    ipv6_addr_t error_src_addr;
    /** Error Destination Address */
    ipv6_addr_t error_dst_addr;

    /** Type specific information
     * NODE_UNREACHABLE, the Type-Specific Information field is the Unreachable Node Address
     * FLOW_STATE_NOT_SUPPORTED, the Type-Specific Information field is empty
     * OPTION_NOT_SUPPORTED, the Type-Specific Information field is uint8_t unsupported_option;
     */
    dsr_error_type_meta_t type_specific_information;
}dsr_error_option_t;

typedef struct{
    /** not used */
    uint8_t empty;
    /** option type */
    uint8_t opt_type;
    /** option data length 
    *   MUST be set equal to (4 * n) + 6, where n is the number of addresses
    *   in the Route Request Option
    */
    uint8_t opt_data_length;
    union{
        /** the Last Hop External L bit */
        uint8_t last_hop_external : 1;
        /** reserved unused bits MUST be 0 */
        uint8_t reserved_bits : 7;
    }flags;
    /** pointer to the array of the source route hops 
     * (n = (Opt Data Len - 1) / 4)
     * */
    ipv6_addr_t* address_array;
}dsr_route_reply_option_t;






#ifdef __cplusplus
}
#endif

#endif /* GNRC_DSR_DATA_TYPES_H_ */
/**
 * @}
 */
